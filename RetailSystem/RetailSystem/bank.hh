// This file is generated by omniidl (C++ backend)- omniORB_4_1. Do not edit.
#ifndef __bank_hh__
#define __bank_hh__

#ifndef __CORBA_H_EXTERNAL_GUARD__
#include <omniORB4/CORBA.h>
#endif

#ifndef  USE_stub_in_nt_dll
# define USE_stub_in_nt_dll_NOT_DEFINED_bank
#endif
#ifndef  USE_core_stub_in_nt_dll
# define USE_core_stub_in_nt_dll_NOT_DEFINED_bank
#endif
#ifndef  USE_dyn_stub_in_nt_dll
# define USE_dyn_stub_in_nt_dll_NOT_DEFINED_bank
#endif






#ifdef USE_stub_in_nt_dll
# ifndef USE_core_stub_in_nt_dll
#  define USE_core_stub_in_nt_dll
# endif
# ifndef USE_dyn_stub_in_nt_dll
#  define USE_dyn_stub_in_nt_dll
# endif
#endif

#ifdef _core_attr
# error "A local CPP macro _core_attr has already been defined."
#else
# ifdef  USE_core_stub_in_nt_dll
#  define _core_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _core_attr
# endif
#endif

#ifdef _dyn_attr
# error "A local CPP macro _dyn_attr has already been defined."
#else
# ifdef  USE_dyn_stub_in_nt_dll
#  define _dyn_attr _OMNIORB_NTDLL_IMPORT
# else
#  define _dyn_attr
# endif
#endif





_CORBA_MODULE Bank

_CORBA_MODULE_BEG

#ifndef __Bank_mrecord__
#define __Bank_mrecord__

  class record;

  class record_Helper {
  public:
    static void add_ref(record*);
    static void remove_ref(record*);
    static void marshal(record*, cdrStream&);
    static record* unmarshal(cdrStream&);
  };

  typedef _CORBA_Value_Var    <record,record_Helper> record_var;
  typedef _CORBA_Value_Member <record,record_Helper> record_member;
  typedef _CORBA_Value_OUT_arg<record,record_Helper> record_out;

#endif // __Bank_mrecord__

  class record : 
    public virtual ::CORBA::ValueBase
  {
  public:  
    // Standard mapping
    typedef record*    _ptr_type;
    typedef record_var _var_type;

    static _ptr_type _downcast(::CORBA::ValueBase*);
    

#ifdef OMNI_HAVE_COVARIANT_RETURNS
    virtual record* _copy_value();
#else
    virtual ::CORBA::ValueBase* _copy_value();
#endif

    // Definitions in this scope
    

    // Operations and attributes
    

    // Accessors for public members
    virtual const char* source() const = 0;
    virtual void source(char* _value) = 0;
    virtual void source(const char* _value) = 0;
    virtual void source(const ::CORBA::String_var& _value) = 0;

    void source(const ::CORBA::String_member& _value) {
      source((const char*)_value);
    }


    virtual const char* target() const = 0;
    virtual void target(char* _value) = 0;
    virtual void target(const char* _value) = 0;
    virtual void target(const ::CORBA::String_var& _value) = 0;

    void target(const ::CORBA::String_member& _value) {
      target((const char*)_value);
    }


    virtual ::CORBA::Double amount() const = 0;
    virtual void amount(::CORBA::Double _value) = 0;


  

  protected:
    // Accessors for private members
    

  public:
    // omniORB internal
    virtual const char* _NP_repositoryId() const;
    virtual const char* _NP_repositoryId(::CORBA::ULong& _hashval) const;

    virtual const _omni_ValueIds* _NP_truncatableIds() const;

    virtual ::CORBA::Boolean _NP_custom() const;

    virtual void* _ptrToValue(const char* id);

    static void _NP_marshal(record*, cdrStream&);
    static record* _NP_unmarshal(cdrStream&);
    

    virtual void _PR_marshal_state(cdrStream&) const;
    virtual void _PR_unmarshal_state(cdrStream&);
    virtual void _PR_copy_state(record*);

    static _core_attr const char* _PD_repoId;

  protected:
    record();
    virtual ~record();

  private:
    // Not implemented
    record(const record &);
    void operator=(const record &);
  };

  class record_init : public ::CORBA::ValueFactoryBase
  {
  public:
    record_init();
    virtual ~record_init();

    virtual ::CORBA::ValueBase* create_for_unmarshal();

    static record_init* _downcast(::CORBA::ValueFactory _v);
    virtual void* _ptrToFactory(const char* _id);
  };

  class recordList_var;

  class recordList : public _CORBA_Unbounded_Sequence_Value< record, _CORBA_Value_Element< record, record_Helper > , record_Helper >  {
  public:
    typedef recordList_var _var_type;
    inline recordList() {}
    inline recordList(const recordList& _s)
      : _CORBA_Unbounded_Sequence_Value< record, _CORBA_Value_Element< record, record_Helper > , record_Helper > (_s) {}

    inline recordList(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_Value< record, _CORBA_Value_Element< record, record_Helper > , record_Helper > (_max) {}
    inline recordList(_CORBA_ULong _max, _CORBA_ULong _len, record** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_Value< record, _CORBA_Value_Element< record, record_Helper > , record_Helper > (_max, _len, _val, _rel) {}

  

    inline recordList& operator = (const recordList& _s) {
      _CORBA_Unbounded_Sequence_Value< record, _CORBA_Value_Element< record, record_Helper > , record_Helper > ::operator=(_s);
      return *this;
    }
  };

  class recordList_out;

  class recordList_var {
  public:
    inline recordList_var() : _pd_seq(0) {}
    inline recordList_var(recordList* _s) : _pd_seq(_s) {}
    inline recordList_var(const recordList_var& _s) {
      if( _s._pd_seq )  _pd_seq = new recordList(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~recordList_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline recordList_var& operator = (recordList* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline recordList_var& operator = (const recordList_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new recordList;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_Value_Element< record, record_Helper >  operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline recordList* operator -> () { return _pd_seq; }
    inline const recordList* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator recordList& () const { return *_pd_seq; }
#else
    inline operator const recordList& () const { return *_pd_seq; }
    inline operator recordList& () { return *_pd_seq; }
#endif
      
    inline const recordList& in() const { return *_pd_seq; }
    inline recordList&       inout()    { return *_pd_seq; }
    inline recordList*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline recordList* _retn() { recordList* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class recordList_out;
    
  private:
    recordList* _pd_seq;
  };

  class recordList_out {
  public:
    inline recordList_out(recordList*& _s) : _data(_s) { _data = 0; }
    inline recordList_out(recordList_var& _s)
      : _data(_s._pd_seq) { _s = (recordList*) 0; }
    inline recordList_out(const recordList_out& _s) : _data(_s._data) {}
    inline recordList_out& operator = (const recordList_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline recordList_out& operator = (recordList* _s) {
      _data = _s;
      return *this;
    }
    inline operator recordList*&()  { return _data; }
    inline recordList*& ptr()       { return _data; }
    inline recordList* operator->() { return _data; }

    inline _CORBA_Value_Element< record, record_Helper >  operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    recordList*& _data;

  private:
    recordList_out();
    recordList_out& operator=(const recordList_var&);
  };

  class recordListString_var;

  class recordListString : public _CORBA_Unbounded_Sequence_String {
  public:
    typedef recordListString_var _var_type;
    inline recordListString() {}
    inline recordListString(const recordListString& _s)
      : _CORBA_Unbounded_Sequence_String(_s) {}

    inline recordListString(_CORBA_ULong _max)
      : _CORBA_Unbounded_Sequence_String(_max) {}
    inline recordListString(_CORBA_ULong _max, _CORBA_ULong _len, char** _val, _CORBA_Boolean _rel=0)
      : _CORBA_Unbounded_Sequence_String(_max, _len, _val, _rel) {}

  

    inline recordListString& operator = (const recordListString& _s) {
      _CORBA_Unbounded_Sequence_String::operator=(_s);
      return *this;
    }
  };

  class recordListString_out;

  class recordListString_var {
  public:
    inline recordListString_var() : _pd_seq(0) {}
    inline recordListString_var(recordListString* _s) : _pd_seq(_s) {}
    inline recordListString_var(const recordListString_var& _s) {
      if( _s._pd_seq )  _pd_seq = new recordListString(*_s._pd_seq);
      else              _pd_seq = 0;
    }
    inline ~recordListString_var() { if( _pd_seq )  delete _pd_seq; }
      
    inline recordListString_var& operator = (recordListString* _s) {
      if( _pd_seq )  delete _pd_seq;
      _pd_seq = _s;
      return *this;
    }
    inline recordListString_var& operator = (const recordListString_var& _s) {
      if( _s._pd_seq ) {
        if( !_pd_seq )  _pd_seq = new recordListString;
        *_pd_seq = *_s._pd_seq;
      } else if( _pd_seq ) {
        delete _pd_seq;
        _pd_seq = 0;
      }
      return *this;
    }
    inline _CORBA_String_element operator [] (_CORBA_ULong _s) {
      return (*_pd_seq)[_s];
    }

  

    inline recordListString* operator -> () { return _pd_seq; }
    inline const recordListString* operator -> () const { return _pd_seq; }
#if defined(__GNUG__)
    inline operator recordListString& () const { return *_pd_seq; }
#else
    inline operator const recordListString& () const { return *_pd_seq; }
    inline operator recordListString& () { return *_pd_seq; }
#endif
      
    inline const recordListString& in() const { return *_pd_seq; }
    inline recordListString&       inout()    { return *_pd_seq; }
    inline recordListString*&      out() {
      if( _pd_seq ) { delete _pd_seq; _pd_seq = 0; }
      return _pd_seq;
    }
    inline recordListString* _retn() { recordListString* tmp = _pd_seq; _pd_seq = 0; return tmp; }
      
    friend class recordListString_out;
    
  private:
    recordListString* _pd_seq;
  };

  class recordListString_out {
  public:
    inline recordListString_out(recordListString*& _s) : _data(_s) { _data = 0; }
    inline recordListString_out(recordListString_var& _s)
      : _data(_s._pd_seq) { _s = (recordListString*) 0; }
    inline recordListString_out(const recordListString_out& _s) : _data(_s._data) {}
    inline recordListString_out& operator = (const recordListString_out& _s) {
      _data = _s._data;
      return *this;
    }
    inline recordListString_out& operator = (recordListString* _s) {
      _data = _s;
      return *this;
    }
    inline operator recordListString*&()  { return _data; }
    inline recordListString*& ptr()       { return _data; }
    inline recordListString* operator->() { return _data; }

    inline _CORBA_String_element operator [] (_CORBA_ULong _i) {
      return (*_data)[_i];
    }

  

    recordListString*& _data;

  private:
    recordListString_out();
    recordListString_out& operator=(const recordListString_var&);
  };

#ifndef __Bank_mBankService__
#define __Bank_mBankService__

  class BankService;
  class _objref_BankService;
  class _impl_BankService;
  
  typedef _objref_BankService* BankService_ptr;
  typedef BankService_ptr BankServiceRef;

  class BankService_Helper {
  public:
    typedef BankService_ptr _ptr_type;

    static _ptr_type _nil();
    static _CORBA_Boolean is_nil(_ptr_type);
    static void release(_ptr_type);
    static void duplicate(_ptr_type);
    static void marshalObjRef(_ptr_type, cdrStream&);
    static _ptr_type unmarshalObjRef(cdrStream&);
  };

  typedef _CORBA_ObjRef_Var<_objref_BankService, BankService_Helper> BankService_var;
  typedef _CORBA_ObjRef_OUT_arg<_objref_BankService,BankService_Helper > BankService_out;

#endif

  // interface BankService
  class BankService {
  public:
    // Declarations for this interface type.
    typedef BankService_ptr _ptr_type;
    typedef BankService_var _var_type;

    static _ptr_type _duplicate(_ptr_type);
    static _ptr_type _narrow(::CORBA::Object_ptr);
    static _ptr_type _unchecked_narrow(::CORBA::Object_ptr);
    
    static _ptr_type _nil();

    static inline void _marshalObjRef(_ptr_type, cdrStream&);

    static inline _ptr_type _unmarshalObjRef(cdrStream& s) {
      omniObjRef* o = omniObjRef::_unMarshal(_PD_repoId,s);
      if (o)
        return (_ptr_type) o->_ptrToObjRef(_PD_repoId);
      else
        return _nil();
    }

    static _core_attr const char* _PD_repoId;

    // Other IDL defined within this scope.
    
  };

  class _objref_BankService :
    public virtual ::CORBA::Object,
    public virtual omniObjRef
  {
  public:
    recordList* listHistory(const char* account, const char* password);
    recordListString* listInListString(const char* account, const char* password);

    inline _objref_BankService()  { _PR_setobj(0); }  // nil
    _objref_BankService(omniIOR*, omniIdentity*);

  protected:
    virtual ~_objref_BankService();

    
  private:
    virtual void* _ptrToObjRef(const char*);

    _objref_BankService(const _objref_BankService&);
    _objref_BankService& operator = (const _objref_BankService&);
    // not implemented

    friend class BankService;
  };

  class _pof_BankService : public _OMNI_NS(proxyObjectFactory) {
  public:
    inline _pof_BankService() : _OMNI_NS(proxyObjectFactory)(BankService::_PD_repoId) {}
    virtual ~_pof_BankService();

    virtual omniObjRef* newObjRef(omniIOR*,omniIdentity*);
    virtual _CORBA_Boolean is_a(const char*) const;
  };

  class _impl_BankService :
    public virtual omniServant
  {
  public:
    virtual ~_impl_BankService();

    virtual recordList* listHistory(const char* account, const char* password) = 0;
    virtual recordListString* listInListString(const char* account, const char* password) = 0;
    
  public:  // Really protected, workaround for xlC
    virtual _CORBA_Boolean _dispatch(omniCallHandle&);

  private:
    virtual void* _ptrToInterface(const char*);
    virtual const char* _mostDerivedRepoId();
    
  };


_CORBA_MODULE_END



_CORBA_MODULE POA_Bank
_CORBA_MODULE_BEG

  class BankService :
    public virtual Bank::_impl_BankService,
    public virtual ::PortableServer::ServantBase
  {
  public:
    virtual ~BankService();

    inline ::Bank::BankService_ptr _this() {
      return (::Bank::BankService_ptr) _do_this(::Bank::BankService::_PD_repoId);
    }
  };

_CORBA_MODULE_END



_CORBA_MODULE OBV_Bank
_CORBA_MODULE_BEG

  class record :
    public virtual Bank::record,
    public virtual ::CORBA::DefaultValueRefCountBase
  {
  public:
    record();
    record(const char* _source, const char* _target, ::CORBA::Double _amount);
    virtual ~record();

  public:
    virtual const char* source() const ;
    virtual void source(char* _value) ;
    virtual void source(const char* _value) ;
    virtual void source(const ::CORBA::String_var& _value) ;


    virtual const char* target() const ;
    virtual void target(char* _value) ;
    virtual void target(const char* _value) ;
    virtual void target(const ::CORBA::String_var& _value) ;


    virtual ::CORBA::Double amount() const ;
    virtual void amount(::CORBA::Double _value) ;


  

  protected:
    

  private:
    ::CORBA::String_member _pd_source;
    ::CORBA::String_member _pd_target;
    ::CORBA::Double _pd_amount;
  
  };

_CORBA_MODULE_END





#undef _core_attr
#undef _dyn_attr



inline void
Bank::BankService::_marshalObjRef(::Bank::BankService_ptr obj, cdrStream& s) {
  omniObjRef::_marshal(obj->_PR_getobj(),s);
}




#ifdef   USE_stub_in_nt_dll_NOT_DEFINED_bank
# undef  USE_stub_in_nt_dll
# undef  USE_stub_in_nt_dll_NOT_DEFINED_bank
#endif
#ifdef   USE_core_stub_in_nt_dll_NOT_DEFINED_bank
# undef  USE_core_stub_in_nt_dll
# undef  USE_core_stub_in_nt_dll_NOT_DEFINED_bank
#endif
#ifdef   USE_dyn_stub_in_nt_dll_NOT_DEFINED_bank
# undef  USE_dyn_stub_in_nt_dll
# undef  USE_dyn_stub_in_nt_dll_NOT_DEFINED_bank
#endif

#endif  // __bank_hh__

